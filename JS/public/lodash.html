<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lodash Tutorial</title>
    <script src="./js/bootstrap.bundle.min.js"></script>
    <script src="./js/lodash.min.js"></script>
    <script src="./js/lodash.js"></script>
    <script src="./js/index.js"></script>
    <link rel="stylesheet" href="./css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="./css/index.css">
</head>

<body>
    <button id="scrollTopBtn" title="Go to top">⬆</button>
    <h1 class="center">Lodash Tutorial</h1>
    <h2 class="center">Getting Started with Lodash</h2>
    <a href="./index.html" rel="noopener noreferrer">
        <button class="btn btn-primary">← Back</button>
    </a>
    <div class="container">
        <p>Lodash is a modern JavaScript utility library delivering modularity, performance, and extras.</p>
        <div class="input-group input-group-sm mb-3">
            <span class="input-group-text txt-bold">Search any lodash methods</span>
            <input type="text" class="form-control" id="searchBox" aria-label="Sizing example input"
                aria-describedby="inputGroup-sizing-sm">
        </div>
        <div id="noResults" style="display: none;text-align: center;color: red;">No results found </div>
        <div class="method-block" data-name="chunk" id="chunk">
            <div class="row">
                <h4>_.chunk(array, size)</h4>
                <p>Creates an array of elements split into groups the length of size.</p>
                <pre>
                    <code>_.chunk(['a', 'b', 'c', 'd'], 2); // => [['a', 'b'], ['c', 'd']]
                    </code>
                    const items = [1, 2, 3, 4, 5, 6, 7];
                    const chunked = _.chunk(items, 3);
                    console.log(chunked);
                    <span class="badge text-bg-success">Output</span> : [ [1, 2, 3] , [4, 5, 6] , [7]]
                </pre>
                <p><span class="badge text-bg-warning">Note</span> : If size is 0 or less, you'll get an empty array</p>
                <pre>
                    _.chunk([1, 2, 3], 0); // => []
                </pre>
            </div>
            <hr>
        </div>
        <div class="method-block" data-name="compact" id="compact">
            <div class="row">
                <h4>_.compact(array)</h4>
                <p>Removes all falsy values from an array.</p>
                <p>Falsy Values in js: <b>false</b> , <b>0</b> , <b>'' (empty string)</b> , <b>null</b> ,
                    <b>undefined</b> ,
                    <b>NaN</b>
                </p>
                <pre>

                    const messyArray = [0, 1,,3,2,1, false, 2, '', 3, null, undefined, NaN,'hi'];
                    const cleanArray = _.compact(messyArray);
                    console.log(cleanArray); 
                    <span class="badge text-bg-success">Output</span> : [1,3,2,1,2,3, 'hi']
                </pre>
                <p><span class="badge text-bg-warning">Note</span> : It only removes falsy values, not other
                    "empty-like"
                    values like [] or {}.</p>
                <pre>
                _.compact([{}, [], 0, false]);  // Output: [{}, []] — only 0 and false are removed
            </pre>
            </div>
            <hr>
        </div>

        <div class="method-block" data-name="concat" id="concat">
            <div class="row">
                <h4> _.concat(array, values...)</h4>
                <p>Creates a new array by concatenating the given arrays and/or values.</p>
                <pre>
                const selected = ['Apple'];
                const newItems = ['Banana', 'Mango'];
                const updatedList = _.concat(selected, newItems, 'Orange');
                console.log(updatedList); 
                <span class="badge text-bg-success">Output</span> : ['Apple', 'Banana', 'Mango', 'Orange']
            </pre>
                <p><span class="badge text-bg-warning">Note</span> : If you pass nested arrays, only the first level is
                    added directly.</p>
                <pre>
                    _.concat([1], [[2, 3]]); // Output: [1, [2, 3]] — not [1, 2, 3]
                </pre>
            </div>

            <hr>
        </div>
        <div class="method-block" data-name="difference" id="difference">
            <div class="row">
                <h4>_.difference(array, values)</h4>
                <p>Returns a new array with the values from the first array that are not present in the second (or more)
                    arrays.</p>
                <pre>
                const allTags = ['React', 'Angular', 'Vue', 'Svelte','Node.js'];
                const selectedTags = ['React', 'Vue'];
                const unselected = _.difference(allTags, selectedTags);
                console.log(unselected);
                <span class="badge text-bg-success">Output</span> : ['Angular', 'Svelte', 'Node.js']
            </pre>
                <p><span class="badge text-bg-warning">Note</span> : It compares values using strict equality (===). It
                    only
                    works well for primitive values like strings, numbers, etc.</p>
            </div>
            <hr>
        </div>
        <div class="method-block" data-name="differenceBy" id="differenceBy">

            <div class="row">
                <h4>_.differenceBy(array, values, iteratee)</h4>
                <p>Returns a new array with the values from the first array that are not present in the second (or more)
                    arrays.</p>
                <pre>
                const setA = [{ id: 1 }, { id: 2 }, { id: 3 }];
                const setB = [{ id: 2 }];
                const resultSet = _.differenceBy(setA, setB, 'id');
                console.log(resultSet);
                <span class="badge text-bg-success">Output</span> : [ { id: 1 }, { id: 3 } ]
            </pre>
                <p><span class="badge text-bg-warning">Note</span> : It only does shallow comparison, not deep.</p>
                <pre>
                const setA = [{ id: 1 }, { id: 2 }, { id: 3 },{ id: 3 }];
                const setB = [{ id: 2 }];
                const resultSet = _.differenceBy(setA, setB, 'id');
                console.log(resultSet);
                <span class="badge text-bg-success">Output</span> : [ { id: 1 }, { id: 3 }, { id: 3 } ]
            </pre>
            </div>
            <hr>
        </div>
        <div class="method-block" data-name="differenceWith" id="differenceWith">
            <div class="row">
                <h4>_.differenceWith(array, values, comparator)</h4>
                <p>Returns a new array with the values from the first array that are not present in the second (or more)
                    arrays.</p>
                <pre>
                const aSet = [
                        { id: 1,name:'Alice' }, 
                        { id: 2,name:'Bob' }, 
                        { id: 3,name:'Charlie' },
                        { id: 5 ,name:'Logi' }, 
                        { id: 6 ,name:'Ravi' }
                    ];

                const bSet = [
                    { id: 2 ,name:'Raja' },
                    { id: 2 ,name:'Rani' },
                    { id: 5 ,name:'Logi' }
                ];
                const setresult = _.differenceWith(aSet, bSet, (a, b) => a.id == b.id && a.name == b.name);
                console.log(setresult);
                <span class="badge text-bg-success">Output</span> :
                [
                    { id: 1, name: 'Alice' },
                    { id: 2, name: 'Bob' },
                    { id: 3, name: 'Charlie' },
                    { id: 6, name: 'Ravi' }
                ];
            </pre>
                <p>
                    <span class="badge text-bg-warning">Note</span> : Remove from aSet if both id and name match any
                    object
                    in bSet
                </p>
            </div>
            <hr>
        </div>
        <div class="method-block" data-name="drop" id="drop">
            <div class="row">
                <h4>_.drop(array, n=1)</h4>
                <p>Creates a new array with the first n elements removed from the original array.</p>
                <pre>
                <p>E.g : 1</p>
                const numbers = [1, 2, 3, 4, 5];
                const dropped = _.drop(numbers, 2);
                console.log(dropped);
                <span class="badge text-bg-success">Output</span> : [ 3, 4, 5 ]
                <p>E.g : 2</p>
                const dataArr = [
                    { id: 1, name: 'Alice' }, 
                    { id: 2, name: 'Bob' }, 
                    { id: 3, name: 'Charlie' }, 
                    { id: 4, name: 'David' }, 
                    { id: 5, name: 'Eve' }
                ];
                const droppedArr = _.drop(dataArr, 2);
                console.log(droppedArr);
               <span class="badge text-bg-success">Output</span> : 
                        [ 
                            { id: 3, name: 'Charlie' }, 
                            { id: 4, name: 'David' }, 
                            { id: 5, name: 'Eve' } 
                        ]
            </pre>
            </div>
            <hr>
        </div>
        <div class="method-block" data-name="fill" id="fill">
            <div class="row">
                <h4> _.fill(array, fill value, start, end)</h4>
                <p>Fills elements of an array with a specific value from start index to end index (not inclusive).</p>
                <pre>
                <p>E.g : 1</p>
                const arr = [1, 2, 3];
                _.fill(arr, '*');
                console.log(arr);
                <span class="badge text-bg-success">Output</span> : ['*', '*', '*']
                <p>E.g : 2</p>
                const arr2 = [1, 2, 3, 4, 5];
                _.fill(arr2, 0, 1, 4);
                console.log(arr2);
                <span class="badge text-bg-success">Output</span> : [1, 0, 0, 0, 5] - fills elements from index 1 to 4 with 0, 4 is not included
             </pre>
            </div>
            <hr>
        </div>
        <div class="method-block" data-name="findIndex" id="findIndex">
            <div class="row">
                <h4>_.findIndex(array, condition)</h4>
                <p>Returns the index of the first element in the array that matches the condition you define. If nothing
                    matches, it returns -1.</p>
                <pre>
                <p>E.g : 1</p>
               const users = [
                    { id: 1, name: 'Anbu' },
                    { id: 2, name: 'Babu' },
                    { id: 3, name: 'Charlie' }
                ];
                const index = _.findIndex(users, user => user.name === 'Babu');
                console.log(index);
                <span class="badge text-bg-success">Output</span> : 1
                <p>E.g : 2</p>
                const index2 = _.findIndex(users, user => user.name === 'David');
                console.log(index2);
                <span class="badge text-bg-success">Output</span> : -1 - David is not found in the array
            </pre>
            </div>
            <hr>
        </div>
        <div class="method-block" data-name="findLastIndex" id="findLastIndex">
            <div class="row">
                <h4>_.findLastIndex(array, condition)</h4>
                <p>Returns the index of the last element in the array that matches the condition you define. If nothing
                    matches, it returns -1.</p>
                <pre>
                <p>E.g : 1</p>
               const usersList = [
                    { id: 1, name: 'Raj' },
                    { id: 2, name: 'John' },
                    { id: 3, name: 'Raj' }
                ];
                    const indexVal = _.findLastIndex(usersList, { name: 'Raj' });
                    console.log(indexVal);
                <span class="badge text-bg-success">Output</span> : 2
            </pre>
                <p>
                    <span class="badge text-bg-warning">Note</span> : findLastIndex starts searching from the end of the
                    array (right to left)
                </p>
            </div>
            <hr>
        </div>
        <div class="method-block" data-name="flatten" id="flatten">
            <div class="row">
                <h4>_.flatten(array)</h4>
                <p>Flattens a nested array into a single-level array.</p>
                <pre>
                E.g : 1
                // If you have a simple nested array, it flattens it to one level
                const nestedArray = [1, [2, 3], [4]];
                const flatArray = _.flatten(nestedArray);
                console.log(flatArray);
                <span class="badge text-bg-success">Output</span> : [1, 2, 3, 4] - only one level is flattened
                E.g : 2
                // If you have deeper nesting, it only flattens one level at a time
                const nestedArray1 = [1, [2, [3, 4]], 5];
                const flatArray1 = _.flatten(nestedArray1);
                console.log(flatArray1);
                <span class="badge text-bg-success">Output</span> : [1, 2, [3, 4], 5]
            </pre>
                <p><span class="badge text-bg-warning">Note</span> : flatten only goes one level deep</p>
            </div>
            <hr>
        </div>
        <div class="method-block" data-name="flattenDeep" id="flattenDeep">
            <div class="row">
                <h4>_.flattenDeep(array)</h4>
                <p>Flattens a nested array recursively.</p>
                <pre>
                E.g : 1
                const mixArr = [1, [2, [3, [4, [5]]]]];
                const resultArr = _.flattenDeep(mixArr);
                console.log(resultArr);
                <span class="badge text-bg-success">Output</span> : [1, 2, 3, 4, 5]
                E.g : 2
               const categories = [
                            ['tech'],
                            ['health', [['yoga', ['meditation']]]],
                            ['sports'],
                            [ ['football']],
                            ['swimming'],
                            ['diving']
                        ];
                const allCategories = _.flattenDeep(categories);
                console.log(allCategories);
                <span class="badge text-bg-success">Output</span> : [
                                    'tech', 'health', 'yoga', 
                                    'meditation','sports', 
                                    'football',  'swimming', 
                                    'diving'
                                ]
            </pre>
            </div>
            <hr>
        </div>
        <div class="method-block" data-name="flattenDepth" id="flattenDepth">
            <div class="row">
                <h4>_.flattenDepth(array, depth)</h4>
                <p>Flattens a nested array up to the specified depth.</p>
                <pre>
                const food = [
                        ['idly', 'dosa'],['briyani', ['samosa']],
                        ['sambar', [['briyani', ['samosa']]]],
                        ['pasta'],['chicken'],
                        ['pizza', [['burger', ['fries']]]],
                        [ ['pizza']],
                        ['burger'],
                        ['fries']
                    ];
                const allFood = _.flattenDepth(food, 5);
                console.log(allFood);
                <span class="badge text-bg-success">Output</span> : 
                    [
                        'idly', 'dosa', 'briyani', 'samosa', 'sambar', 
                        'briyani', 'samosa', 'pasta', 'chicken', 'pizza', 
                        'burger', 'fries', 'pizza', 'burger', 'fries'
                    ]
            </pre>
                <p><span class="badge text-bg-warning">Note</span> : 'briyani', 'samosa', 'pizza', 'burger', and 'fries'
                    appear multiple times because they are repeated in different levels and combinations.
                    <b>_.flattenDepth does NOT remove duplicates</b>
                </p>
            </div>
            <hr>
        </div>
        <div class="method-block" data-name="indexOf" id="indexOf">
            <div class="row">
                <h4>_.indexOf(array, value, [fromIndex=0])</h4>
                <p>Returns the index of the first occurrence of value in the array.
                    Returns -1 if the value is not found.</p>
                <pre>
                    E.g : 1
                    const identity = _.indexOf([10, 20, 30, 20], 20);
                    console.log(identity);
                    <span class="badge text-bg-success">Output</span> : 1 - 20 is found at index 1
                    E.g : 2
                    const selectedColors = ['red', 'green', 'blue'];
                    const chooseColors = ['red', 'blue'];

                    if (_.indexOf(selectedColors, 'green') !== -1) {
                    console.log('Already Available!'); //  green is in selectedColors
                    }

                    if (_.indexOf(chooseColors, 'green') === -1) {
                    console.log('Not Available!'); // green is not in chooseColors
                    }
                </pre>
            </div>
            <hr>
        </div>
        <div class="method-block" data-name="initial" id="initial">
            <div class="row">
                <h4>_.initial(array)</h4>
                <p>Returns a new array with all elements except the last one.</p>
                <pre>
                const numbers = [1, 2, 3, 4, 5];
                const initialNumbers = _.initial(numbers);
                console.log(initialNumbers);
                <span class="badge text-bg-success">Output</span> : [1, 2, 3, 4] - removes the last element (5)
            </pre>
            </div>
            <hr>
        </div>
        <div class="method-block" data-name="intersection" id="intersection">
            <div class="row">
                <div class="col">
                    <h4>_.intersection([arrays])</h4>
                    <p>Returns a new array of values that are included in all given arrays.</p>
                    <pre>
            const fromSearch = ['spa', 'facial', 'massage'];
            const fromFavorites = ['massage', 'haircut', 'spa'];
            const common = _.intersection(fromSearch, fromFavorites);
            <span class="badge text-bg-success">Output</span> : ['spa', 'massage']
                </pre>
                </div>
                <div class="col">
                    <h4>_.intersectionBy(arr1, arr2, iteratee)</h4>
                    <p>compares values based on a given key or function (called an iteratee).</p>
                    <pre>
            const userCart = [
                 { productId: 101 },
                 { productId: 202 }
            ];

            const discountItems = [
                { productId: 202 },
                { productId: 303 }
            ];

            const eligibleDiscounts = _.intersectionBy(userCart, discountItems, 'productId');
            console.log(eligibleDiscounts);
            <span class="badge text-bg-success">Output</span> : [{ productId: 202 }]
                </pre>
                    <p><span class="badge text-bg-warning">Note</span> : It finds common items by comparing their id.
                    </p>
                </div>
            </div>
            <hr>
        </div>
        <div class="method-block" data-name="intersectionWith" id="intersectionWith">
            <div class="row">
                <div class="col">
                    <h4>_.intersectionWith(arr1, arr2, comparator)</h4>
                    <p>compares values using a custom function (called a comparator).</p>
                    <pre>
                        const activeOrders = [
                            { id: 101, status: 'pending' },
                            { id: 102, status: 'shipped' }
                        ];

                        const archived = [
                            { id: 101, status: 'pending' },
                            { id: 102, status: 'cancelled' }
                        ];

                const result = _.intersectionWith(activeOrders, archived, (a, b) => a.id === b.id && a.status === b.status);
            <span class="badge text-bg-success">Output</span> : [{ id: 101, status: 'pending' }]
                </pre>
                </div>
            </div>
            <div class="col">
                <h4>_.join(array, separator)</h4>
                <p>Joins all elements of an array into a string with a specified separator.</p>
                <pre>
                const elements = ['Fire', 'Air', 'Water'];
                const joined = _.join(elements, ' - ');
                console.log(joined);
                <span class="badge text-bg-success">Output</span> : 'Fire - Air - Water'
                
                const breadCrumbs = ['home', 'products', 'mobile'];
                const path = _.join(breadCrumbs, '/');
                <span class="badge text-bg-success">Output</span> : 'home/products/mobile'
                </pre>
                <p><span class="badge text-bg-warning">Note</span> : It only works on flat arrays — doesn't flatten
                    nested arrays. // [1, [2, 3]]</p>
            </div>
            <hr>
        </div>
        <div class="row">
            <div class="method-block" data-name="head" id="head">

                <div class="col">
                    <h4> _.head(array)</h4>
                    <p>Gets the first element of an array.</p>
                    <pre>
                const initialNotifications = [
                        'New message', 
                        'Friend request', 
                        'Update available'
                ];
                console.log(_.head(initialNotifications));
                <span class="badge text-bg-success">Output</span> : 'New message'
                </pre>
                </div>
            </div>
            <div class="method-block" data-name="last" id="last">
                <div class="col">
                    <h4>_.last(array)</h4>
                    <p>Gets the last element of an array.</p>
                    <pre>
                const finalNotifications = [
                        'New message', 
                        'Friend request', 
                        'Update available'
                ];
                console.log(_.last(finalNotifications));
                <span class="badge text-bg-success">Output</span> : 'Update available'
                </pre>
                </div>

            </div>
            <hr>
        </div>
        <div class="row">
            <div class="method-block" data-name="initial" id="initial">
                <div class="col">
                    <h4>_.initial(array)</h4>
                    <p>Gets all elements of an array except the last one.</p>
                    <pre>
        const paths = [
            'Home', 
            'Products', 
            'Electronics', 'Laptops'
        ];
        const breadcrumb = _.initial(paths);
        console.log(breadcrumb);
                <span class="badge text-bg-success">Output</span> : [
                        'Home', 
                        'Products', 
                        'Electronics'
                ]
                </pre>
                </div>
            </div>
            <div class="method-block" data-name="tail" id="tail">
                <div class="col">
                    <h4>_.tail(array)</h4>
                    <p>Gets all elements of an array except the first one.</p>
                    <pre>
        const allReplies = ['Post content', 'Comment 1', 'Comment 2'];
        const commentsOnly = _.tail(allReplies);
        console.log(commentsOnly);
                <span class="badge text-bg-success">Output</span> : ['Comment 1', 'Comment 2']
                </pre>
                </div>
                <hr>
            </div>
            <div class="method-block" data-name="pull" id="pull">
                <div class="col">
                    <h4>_.pull(array, values...)</h4>
                    <p>Removes all occurrences of the specified values from the array.</p>
                    <pre>
                const scores = [90, 80, 90, 90, 70, 70, 71, 80];
                _.pull(scores, 80, 90);
                console.log(scores);
                <span class="badge text-bg-success">Output</span> : [70,70, 71]
                </pre>
                    <p><span class="badge text-bg-warning">Note</span> : It uses strict equality (===), so all values
                        must
                        match exactly.</p>
                </div>
                <div class="col">
                    <h4>_.pullAll(array, [values])</h4>
                    <p>Removes all occurrences of the specified values from the array.</p>
                    <pre>
                let cart = [
                        { productId: 101, name: 'Shampoo' },
                        { productId: 102, name: 'Oil' },
                        { productId: 103, name: 'Soap' }
                    ];
                const toRemove = [{ productId: 102 }];
                _.pullAllBy(cart, toRemove, 'productId');
                console.log(cart);
                <span class="badge text-bg-success">Output</span> : [ 
                    { productId: 101, name: 'Shampoo' }, 
                    { productId: 103, name: 'Soap' }
                 ]
                </pre>
                </div>
            </div>
            <hr>
            <div class="row">
                <div class="method-block" data-name="pullAllWith" id="pullAllWith">
                    <div class="col">
                        <h4>_.pullAllWith</h4>
                        <p>Removes all occurrences of the specified values from the array using a comparator function.
                        </p>
                        <pre>
        let cartItems = [
            { id: 1, name: 'Milk' },
            { id: 2, name: 'Bread' },
            { id: 3, name: 'Milk' }
        ];

        let toDelete = [
            { id: 3, name: 'Milk' }
        ];
        _.pullAllWith(cartItems, toDelete, (a, b) => a.id === b.id && a.name === b.name);
        console.log(cartItems);
        <span class="badge text-bg-success">Output</span> : [ 
            { id: 1, name: 'Milk' }, 
            { id: 2, name: 'Bread' } 
        ]
                </pre>
                    </div>
                    <div class="col">
                        <h4>_.pullAt(array, [indexes])</h4>
                        <p>Removes elements from an array by their indexes.</p>
                        <pre>
                let fruits = [
                    'Apple', 
                    'Banana', 
                    'Cherry', 
                    'Date', 
                    'Berry'
                ];
                _.pullAt(fruits, [1, 3]);
                console.log(fruits);
                <span class="badge text-bg-success">Output</span> : [ 
                    'Apple', 
                    'Cherry', 
                    'Berry'
                ]
                </pre>
                    </div>
                    <hr>
                </div>
                <div class="method-block" data-name="remove" id="remove">
                    <div class="row">
                        <div class="col">
                            <h4>_.remove(array, predicate)</h4>
                            <p>Removes all elements from an array that the predicate returns truthy for.</p>
                            <pre>
               let todos = [
                    { task: 'Do laundry', done: true },
                    { task: 'Buy groceries', done: false },
                    { task: 'Clean room', done: true },
                    { task: 'Prepare dinner', done: true }
                ];
                const completed = _.remove(todos, todo => todo.done);
                console.log(completed);
                <span class="badge text-bg-success">Output</span> : 
                [ 
                    { task: 'Do laundry', done: true }, 
                    { task: 'Clean room', done: true },
                    { task: 'Prepare dinner', done: true }
                ]
                </pre>
                        </div>
                        <div class="col">
                            <h4>_.reverse</h4>
                            <p>Reverses the elements of an array in place.</p>
                            <pre>
                let messages = [
                    'Hi', 
                    'How are you?',  
                    'Bye'
                ];
                _.reverse(messages);
                console.log(messages);
                <span class="badge text-bg-success">Output</span> : [
                    'Bye', 
                    'How are you?', 
                    'Hi'
                ]
                </pre>
                        </div>
                    </div>
                    <hr>
                </div>
                <div class="method-block" data-name="sortBy" id="sortBy">
                    <div class="row">
                        <div class="col">
                            <h4> _.sortedUniq(array)</h4>
                            <p>Creates a duplicate-free version of an array sorted in ascending order. (small to big)
                            </p>
                            <pre>
                let ages = [1,2,3,4,5,6,7,7,8,9,9,10];
                let unique = _.sortedUniq(ages);
                console.log(unique);
                <span class="badge text-bg-success">Output</span> : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
                </pre>
                            <p><span class="badge text-bg-warning">Note</span> : its does not work with nested arrays or
                                objects.
                                its only works correctly if the array is already sorted in ascending order.</p>
                        </div>
                        <div class="col">
                            <h4>_.sortBy(array, [iteratee=_.identity])</h4>
                            <p>Creates a duplicate-free version of an array sorted in ascending order, based on the
                                results of
                                the
                                iteratee.</p>
                            <pre>
                const data = [
                    { id: 1, age: 20 },
                    { id: 2, age: 89 },
                    { id: 1, age: 9 },
                    { id: 2, age: 34 },
                    { id: 1, age: 24 },
                    { id: 2, age: 22 }
                ];
                let sortedByAge = _.sortBy(data, 'age');
                console.log(sortedByAge);
                <span class="badge text-bg-success">Output</span> : [ 
                        { id: 1, age: 9 }, 
                        { id: 1, age: 20 }, 
                        { id: 1, age: 24 }, 
                        { id: 2, age: 22 }, 
                        { id: 2, age: 34 },
                        { id: 2, age: 89 } 
                 ]
                </pre>
                        </div>
                    </div>
                    <hr>
                </div>
                <div class="method-block" data-name="orderBy" id="orderBy">
                    <div class="row">
                        <div class="col">
                            <h4>_.orderBy</h4>
                            <p>Creates a new array with elements sorted in defined order.</p>
                            <pre>

                E.g : 1
                const persons = [
                    { id: 1, age: 20 },
                    { id: 2, age: 89 },
                    { id: 1, age: 9 },
                    { id: 2, age: 34 },
                    { id: 1, age: 24 },
                    { id: 2, age: 22 }
            ];
                const sortedDesc = _.orderBy(persons, ['age'], ['desc']);
                console.log(sortedDesc);
                <span class="badge text-bg-success">Output</span> : [
                    { id: 2, age: 89 },
                    { id: 2, age: 34 },
                    { id: 1, age: 24 },
                    { id: 2, age: 22 },
                    { id: 1, age: 20 },
                    { id: 1, age: 9 }
                ]

                E.g : 2
                const vegetables = [
                    { name: 'Carrot', kg: 5 },
                    { name: 'Broccoli', kg: 2 },
                    { name: 'Cauliflower', kg: 8 },
                    { name: 'Spinach', kg: 3 }
                ];
                let sortedVegetables = _.orderBy(vegetables, ['kg'], ['asc']);
                console.log(sortedVegetables);
                <span class="badge text-bg-success">Output</span> : [
                    { name: 'Broccoli', kg: 2 },
                    { name: 'Spinach', kg: 3 },
                    { name: 'Carrot', kg: 5 },
                    { name: 'Cauliflower', kg: 8 }
                ]
                </pre>
                        </div>
                        <div class="col">
                            <div>
                                <h4>_.Uniq</h4>
                                <p>Creates a duplicate-free version of an array.</p>
                                <pre>
                const countries = ['India', 'USA', 'India', 'UK', 'USA'];
                const uniqueCountries = _.uniq(countries);
                console.log(uniqueCountries);
                <span class="badge text-bg-success">Output</span> : ['India', 'USA', 'UK']
                </pre>
                            </div>
                            <div>
                                <h4>_.UniqBy</h4>
                                <p>Creates a duplicate-free version of an array based on a specified iteratee.</p>
                                <pre>
                const namesArr = [
                    { id: 1, name: 'Anbu' },
                    { id: 1, name: 'Anbu' },
                    { id: 1, name: 'Villan' },
                    { id: 2, name: 'Chandra' },
                    { id: 1, name: 'Bhuvana' },
                    { id: 1, name: 'Bhuvana' },
                    { id: 2, name: 'Josh' },
                    { id: 2, name: 'Loki' },
                    { id: 2, name: 'Loki' },
                ];
                const uniqueUsers = _.uniqBy(namesArr, 'name');
                console.log(uniqueUsers);
                <span class="badge text-bg-success">Output</span> : [
                    { id: 1, name: 'Anbu' },
                    { id: 2, name: 'Chandra' },
                    { id: 1, name: 'Bhuvana' },
                    { id: 2, name: 'Josh' },
                    { id: 2, name: 'Loki' },
                    { id: 1, name: 'Villan' }
                ]
                </pre>
                            </div>
                        </div>
                    </div>
                    <hr>
                </div>
                <div class="method-block" data-name="countBy" id="countBy">
                    <div class="row">
                        <div class="col">
                            <h4>_.countBy(array, [iteratee=_.identity])</h4>
                            <p>Returns an object where keys are the group names, and values are the counts.</p>
                            <pre>
                    const numbers = [1, 2, 3, 4, 5, 6];
                    const result = _.countBy(numbers, n => n % 2 === 0 ? 'even' : 'odd');
                    console.log(result);
                    <span class="badge text-bg-success">Output</span>: { odd: 3, even: 3 }

                    const usersArr = [
                        { name: 'A', type: 'admin' },
                        { name: 'B', type: 'user' },
                        { name: 'C', type: 'admin' },
                        { name: 'D', type: 'guest' }
                    ];
                    const res = _.countBy(usersArr, 'type');
                    console.log(res);
                    <span class="badge text-bg-success">Output</span> : { admin: 2, user: 1, guest: 1 }
                            </pre>
                        </div>
                    </div>
                    <hr>
                </div>
                <div class="row">
                    <div class="col">
                        <div class="method-block" data-name="forEach" id="forEach">
                            <h4>_.forEach(collection, iteratee)</h4>
                            <p>Iterates over elements in a collection (array or object) and runs the iteratee function
                                for
                                each item.</p>
                            <pre>
                    const fruitsItems = ['apple', 'banana', 'orange'];
                    _.forEach(fruitsItems, (fruit, index) => {
                    console.log(`${index}: ${fruit}`);
                    });
                            <span class="badge text-bg-success">Output</span>:
                            // 0: apple
                            // 1: banana
                            // 2: orange

                                        E.g : 2
                    const userObj = { name: 'Alice', age: 25, role: 'admin' };
                    _.forEach(userObj, (value, key) => {
                    console.log(`${key}: ${value}`);
                    });
                                        <span class="badge text-bg-success">
                    Output  
                                        </span>:
                                        // name: Alice
                                        // age: 25
                                        // role: admin
                        </pre>
                            <p><span class="badge text-bg-warning">Note</span> : Works for both arrays and objects.</p>
                            <hr>
                        </div>
                    </div>
                    <div class="col">
                        <div class="method-block" data-name="every" id="every">
                            <h4>_.every</h4>
                            <p>Checks if all elements in a collection pass the condition defined by the iteratee.</p>
                            <pre>
                    const integers = [1, 2, 3, 4,-2];
                    const allPositive = _.every(integers, n => n > 0);
                    console.log(allPositive); 
                    <span class="badge text-bg-success">Output:</span> false - because -2 is not positive

                    E.g : 2
                    const dataList = [
                    { name: 'A', age: 25 },
                    { name: 'B', age: 30 },
                    { name: 'C', age: 22 }
                    ];
                    const listRes = _.every(dataList, user => user.age > 20);
                    console.log(listRes); 
                    <span class="badge text-bg-success">Output </span> : true
                        </pre>
                            <hr>
                        </div>
                    </div>
                </div>
                <div class="method-block" data-name="filter" id="filter">
                    <div class="row">
                        <div class="col">
                            <h4>_.filter(collection, predicate)</h4>
                            <p>Creates a new array with all elements that pass the condition defined by the predicate.
                            </p>
                            <pre>
const Allusers = [
        { name: 'A', active: true },
        { name: 'B', active: false },
        { name: 'C', active: true }
];

const activeUsers = _.filter(Allusers, 'active');
console.log(activeUsers);
<span class="badge text-bg-success">Output</span> :
// [
//   { name: 'A', active: true },
//   { name: 'C', active: true }
// ]

<p><span class="badge text-bg-warning">Note :</span>Similar to JavaScript’s native .filter(), but works with arrays and objects.</p>
E.g : 2
const runs = {
  John: 45,
  Alice: 90,
  Bob: 32
};

const passed = _.filter(runs, score => score >= 40);
console.log(passed); 
<span class="badge text-bg-success">Output</span>: 
// [45, 90]
                        </pre>
                            <p> <span class="badge text-bg-warning">Note :</span>It returns values only (not keys) when
                                filtering objects.</p>
                        </div>
                        <div class="col">
                            <h4>_.find(collection, predicate, [fromIndex=0])</h4>
                            <p>Returns the first element in the collection that satisfies the predicate function.</p>
                            <pre>
const mixedNumbers = [1, 3, 5, 6, 8, 10];
const firstEven = _.find(mixedNumbers, n => n % 2 === 0);
console.log(firstEven); 
<span class="badge text-bg-success">Output :</span> 6
                        </pre>
                        </div>
                    </div>
                    <hr>
                </div>
                <div class="row">
                    <div class="col">
                        <div class="method-block" data-name="flatMap" id="flatMap">
                            <div>
                                <h4>_.flatMap(collection, iteratee)</h4>
                                <p>Applies a function (iteratee) to each element of the collection.
                                    Flattens the result one level deep.</p>
                                <pre>
const nameStr = ['Kesava', 'Raj'];
const resultStr = _.flatMap(nameStr, name => [name, name.length]);
console.log(resultStr);
        <span class="badge text-bg-success">Output :</span>
       ['Kesava', 6, 'Raj', 3]

       E.g : 2
const listeners = [
        { name: 'Alice', tags: ['admin', 'editor'] },
        { name: 'Bob', tags: ['user'] }
];
const tags = _.flatMap(listeners, user => user.tags);
console.log(allTags);
<span class="badge text-bg-success">Output :</span>
// ['admin', 'editor', 'user']
</pre>
                            </div>
                            <hr>
                        </div>
                    </div>
                    <div class="col">
                        <div class="method-block" data-name="flatMapDeep" id="flatMapDeep">
                            <h4>_.flatMapDeep</h4>
                            <p> Runs iteratee for each element in the collection.
                                Flattens the result completely (deeply).</p>
                            <pre>
const subjects = [
            { name: 'tech', subs: ['mobile', ['ai', ['cloud']]] },
            { name: 'food', subs: ['fruits', ['veg']] }
];
const allSubs = _.flatMapDeep(subjects, cat => cat.subs);
console.log(allSubs);
<span class="badge text-bg-success">Output</span> :
// ['mobile', 'ai', 'cloud', 'fruits', 'veg']
                        </pre>
                            <hr>
                        </div>
                    </div>
                </div>
                <div class="row">
                    <div class="method-block" data-name="groupBy" id="groupBy">
                        <div class="col">
                            <h4> _.groupBy(collection, iteratee)</h4>
                            <p>Splits a collection into groups based on the result of running each element through the
                                iteratee (function or property name).</p>
                            <pre>
                        const nums = [1, 2, 3, 4, 5, 6];
const grouped = _.groupBy(nums, n => n % 2 === 0 ? 'even' : 'odd');
console.log(grouped);
<span class="badge text-bg-success">Output :</span>
// {
//   odd: [1, 3, 5],
//   even: [2, 4, 6]
// }

E.g : 2
const usersAges = [
  { name: 'A', age: 25 },
  { name: 'B', age: 30 },
  { name: 'C', age: 25 }
];
const byAge = _.groupBy(usersAges, 'age');
console.log(byAge);
<span class="badge text-bg-success">Output : </span>
// {
//   25: [{ name: 'A', age: 25 }, { name: 'C', age: 25 }],
//   30: [{ name: 'B', age: 30 }]
// }
                       </pre>
                        </div>
                        <hr>
                    </div>
                    <div class="col">
                        <div class="method-block" data-name="includes" id="includes">
                            <h4>_.includes(collection, value, [fromIndex=0])</h4>
                            <p>Checks whether a collection (array, object, or string) contains the specified value.</p>
                            <pre>
const favs = ['apple', 'banana', 'mango'];
console.log(_.includes(favs, 'banana')); <span class="badge text-bg-success">Output :</span> true
console.log(_.includes(favs, 'grape'));  <span class="badge text-bg-success">Output :</span> false

                        </pre>
                            <hr>
                        </div>
                        <div class="method-block" data-name="keyBy" id="keyBy">
                            <div class="row">
                                <div class="col">
                                    <h4>_.keyBy(collection, iteratee)</h4>
                                    <p>Similar to _.groupBy, but keeps only one item per key, not arrays.</p>
                                    <pre>
  const employees = [
            { id: 101, name: 'Alice' },
            { id: 102, name: 'Bob' },
            { id: 103, name: 'Charlie' }
];
const empResult = _.keyBy(employees, 'id');
console.log(empResult);
<span class="badge text-bg-success">Output :</span>
// {
//   101: { id: 101, name: 'Alice' },
//   102: { id: 102, name: 'Bob' },
//   103: { id: 103, name: 'Charlie' }
// }
                        </pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="row">
                <hr>
                <div class="col">
                    <div class="method-block" data-name="map" id="map">
                        <h4> _.map(collection, iteratee)</h4>
                        <p>Creates a new array by applying a function (iteratee) to each element in a collection. Works
                            with arrays, objects, or objects inside arrays.</p>
                        <pre>
const nos = [1, 2, 3, 4];
const doubled = _.map(nos, n => n * 2);
console.log(doubled); 
<span class="badge text-bg-success">Output :</span>
// [2, 4, 6, 8]
</pre>
                    </div>
                </div>
                <div class="col">
                    <div class="method-block" data-name="reduce" id="reduce">
                        <h4>_.reduce(collection, iteratee, [accumulator])</h4>
                        <p>Reduces a collection (array or object) to a single accumulated value by repeatedly calling an
                            iteratee function.</p>
                        <pre>
            const prices = [10, 20, 30, 40];
            const total = _.reduce(prices, (sum, n) => sum + n, 0);
            console.log(total); 
                            <span class="badge text-bg-success">Output : </span> 100
                    </pre>
                        <p><span class="badge text-bg-warning">Note :</span>
                            sum is the accumulator <br>
                            n is the current item
                        </p>
                    </div>
                </div>
            </div>
            <hr>
            <div class="row">
                <div class="col">
                    <div class="method-block" data-name="sample" id="sample">
                        <h4>_.sample(collection)</h4>
                        <p>Returns a random element from a collection (array or object).</p>
                        <pre>
        const fruitsNames = ['apple', 'banana', 'cherry', 'mango'];
        console.log(_.sample(fruitsNames));  
<span class="badge text-bg-success">Output : </span> "banana" // randomly changes each time
                        </pre>
                        <p><span class="badge text-bg-warning">Note :</span>
                            Does not modify the original collection. random result each time
                        </p>

                    </div>
                </div>
                <div class="col">
                    <div class="method-block" data-name="samplesize" id="samplesize">
                        <h4>_.sampleSize(collection, [n=1])</h4>
                        <p>Returns an array of n random elements from a collection (array or object).</p>
                        <pre>
        const colors = ['red', 'green', 'blue', 'yellow', 'purple'];
        const randomColors = _.sampleSize(colors, 3);           
        console.log(randomColors);
<span class="badge text-bg-success">Output : </span> ['blue', 'red', 'yellow'] // randomly changes each time
                        </pre>
                    </div>
                </div>
            </div>
            <div class="row">
                <hr>
                <div class="col">
                    <div class="method-block" data-name="values" id="values">
                        <h4>_.values(object)</h4>
                        <p>Extract all the values from an object and return them as an array.</p>
                        <pre>
const objectData = { name: 'Raj', age: 25, city: 'Chennai' };
console.log(_.values(objectData));
<span class="badge text-bg-success">Output : </span> ['Raj', 25, 'Chennai']
                        </pre>
                        <p><span class="badge text-bg-warning">Note :</span>
                            Keys: ['name', 'age', 'city'] <br>
                            Values: ['Raj', 25, 'Chennai'] ← what _.values returns.</p>
                    </div>
                </div>
                <div class="col">
                    <div class="method-block" data-name="keys" id="keys">
                        <h4>_.keys(object)</h4>
                        <p>Extract all the keys from an object and return them as an array.</p>
                        <pre>
const objectKeys = { name: 'Raj', age: 25, city: 'Chennai' };
console.log(_.keys(objectKeys));
<span class="badge text-bg-success">Output : </span> ['name', 'age', 'city']
                        </pre>
                    </div>
                </div>
            </div>
            <hr>
            <div class="row">
                <div class="col">
                    <div class="method-block" data-name="entries" id="entries">
                        <h4>_.entries(object)</h4>
                        <p>Converts an object into an array of key-value pairs.</p>
                        <pre>
const ornamentsData = ['chain', 'ring', 'stud', 'neckles'];
console.log(_.entries(ornamentsData)); 
<span class="badge text-bg-success">Output : </span>
[
    ['0', 'chain'], 
    ['1', 'ring'],
    ['2', 'stud'],
    ['3', 'neckles']    
]
             
E.g : 2
const userDetails = { name: 'Raj', age: 25, city: 'Chennai' };
console.log(_.entries(userDetails));
<span class="badge text-bg-success">Output : </span>
[
    ['name', 'Raj'],
    ['age', 25],
    ['city', 'Chennai']
]    
                        </pre>
                    </div>
                </div>
                <div class="col">
                    <div class="method-block" data-name="suffle" id="shuffle">
                        <h4>_.shuffle(collection)</h4>
                        <p>Randomly shuffles the elements of a collection (array or object).</p>
                        <pre>
const participants = { a: 'Raj', b: 'Kesava', c: 'Anbu' };
const shuffledParticipants= _.shuffle(_.values(user));
console.log(shuffledParticipants);
<span class="badge text-bg-success">Output:</span>  ['Kesava', 'Anbu', 'Raj'] // randomly changes each time
                        </pre>
                    </div>
                    <div class="method-block" data-name="some" id="some">
                        <h4>_.some(collection, predicate)</h4>
                        <p>Checks if at least one element in a collection matches the given condition (predicate).</p>
                        <pre>
        const winnersList = [
            { name: 'Raj', active: false },
            { name: 'Anbu', active: true },
            { name: 'Kesava', active: false },
            { name: 'Chandra', active: false },
            { name: 'Josh', active: true }
    ];
const isActive = _.some(winnersList, { active: true });
console.log(isActive);  
<span class="badge text-bg-success">Output:</span> true // because Anbu and Josh are active
                        </pre>
                    </div>
                </div>
            </div>
            <hr>
            <div class="row">
                <div class="col">
                    <div class="method-block" data-name="debounce" id="debounce">
                        <h4>_.debounce(func, wait, [options])</h4>
                        <p>Creates a debounced function that delays invoking func until after wait milliseconds have
                            elapsed since the last time the debounced function was invoked.</p>
                        <pre>
const sayHello = _.debounce((name) => {
         console.log(`Hello, ${name}!`);
    }, 1000);
sayHello('Raj');
sayHello('Anbu');
sayHello('Kesava');

// Only "Hello, Kesava!" will print after 1 second,
// because the last call overrides the earlier ones.

<p><span class="badge text-bg-warning">Note :</span> “I’ll wait X ms to run. If I’m called again during that time, I’ll restart my timer and wait again.”</p>
                        </pre>
                    </div>
                </div>
                <div class="col">
                    <div class="method-block" data-name="throttle" id="throttle">
                        <h4>_.throttle(func, wait, [options])</h4>
                        <p>Allow the function to run only once every X milliseconds, even if it's triggered in between
                            its ignored.</p>
                        <p>Real time example :</p>
                        <p>Imagine you're pressing a button very fast — like 10 times per second.
                            But you want the function to run only once per second no matter how many times you press the
                            button.</p>
                        <pre>
const throttledFunc = _.throttle(() => {
  console.log("Function called at", new Date().toLocaleTimeString());
}, 2000); // 1000ms = 1 second ( it runs only every 2000ms (2 secs).)

// simulate calling it many times
setInterval(() => {
  throttledFunc();
}, 300); // tries to run every 300ms
                        </pre>
                    </div>
                </div>
            </div>
            <hr>
            <div class="row">
                <div class="col">
                    <div class="method-block" data-name="clone" id="clone">
                        <h4>_.clone(value)</h4>
                        <p>Creates a shallow copy (மேலோட்ட நகல்) of the value.</p>
                        <p>ஒரு object-ஐ நகலெடுக்கும் போது,
                            அதில் உள்ள முதன்மை நிலை (first-level) property-களை மட்டும் முழுமையாக நகலெடுக்கும் ஒரு முறை.
                        </p>
                        <p>📦 ஆனால் அந்த object-ல் உள்ள மற்றொரு object (nested object) இருந்தால்,
                            அது அதே memory reference-ஐ பயன்படுத்தும்.
                            அதாவது, அந்த உள்ளமைவான object மாற்றப்படும் போது, original object-யும் பாதிக்கப்படும்.</p>
                        <p>It copies the first level only. If the object has nested objects, the inner objects will
                            still be referenced, not deeply copied.</p>
                        <pre>
const original = { name: 'Kesava', age: 30 };
const copy = _.clone(original);
console.log(copy); // { name: 'Kesava', age: 30 }
copy.name = 'Raj';
console.log(original.name); // 'Kesava' ✅ (not affected)

<span class="badge text-bg-warning">Example with nested objects:</span>

const user = {
  name: 'Kesava',
  address: { city: 'Chennai', zip: 600001 }
};
const clonedUser = _.clone(user);
clonedUser.address.city = 'Coimbatore';
console.log(user.address.city); // 'Coimbatore' ❗ (original object is affected!)
                        </pre>
                    </div>
                </div>
                <div class="col">
                    <div class="method-block" data-name="clonedeep" id="clonedeep">
                        <h4>_.cloneDeep(value)</h4>
                        <p>Creates a deep copy (முழுமையான நகல்) of the value.</p>
                        <p>ஒரு object-ஐ நகலெடுக்கும் போது,
                            அதில் உள்ள அனைத்து நிலை (all levels) property-களையும் முழுமையாக நகலெடுக்கும் ஒரு முறை.
                        </p>
                        <p>📦 இது ஒரு object-இன் அனைத்து உள்ளமைவுகளையும் (nested objects) தனித்தனியாக நகலெடுக்கிறது.
                            அதாவது, original object-யின் எந்த மாற்றமும் இந்த நகலெடுக்கப்பட்ட object-ஐ பாதிக்காது.</p>
                        <p>Deep copy means copying everything, including nested objects or arrays.
                            The copied object is completely separate from the original. Changes to the copy will not
                            affect the original.</p>
                        <pre>
const originalDeepObj = {
    user: 'Kesava',
    details: {
        city: 'Chennai',
        skills: ['JS', 'React']
    }
};

const deepCopyObj = _.cloneDeep(originalDeepObj);
deepCopyObj.details.city = 'Coimbatore';
deepCopyObj.details.skills.push('Lodash');

console.warn("Deep Copy Example:");
console.log(deepCopyObj.details.city); // 'Coimbatore' ✅ changed in deep copy
console.log(deepCopyObj.details.skills); // ['JS', 'React', 'Lodash'] ✅ changed in deep copy

<span class="badge text-bg-warning">Note : </span>Original object remains unchanged
console.warn("Original Object :");
console.log(originalDeepObj.details.city); // 'Chennai' ✅ not changed
console.log(originalDeepObj.details.skills);// ['JS', 'React'] ✅ not changed
                        </pre>
                    </div>
                </div>
            </div>
            <hr>
            <div class="row">
                <div class="col">
                    <div class="method-block" data-name="clonedeepwith" id="clonedeepwith">
                        <h4>_.cloneDeepWith(value, [customizer])</h4>
                        <p>Let’s say we have a user profile object that contains a large image file. We don’t want to
                            clone the image (it’s heavy and unnecessary), so we’ll leave it untouched using a
                            customizer.</p>
                        <pre>
// Simulating an object with a large image blob
const userProfile = {
  name: 'Kesava',
  age: 28,
  profileImage: new Blob(['...'], { type: 'image/png' }),
  preferences: {
    theme: 'dark',
    notifications: true
  }
};
// Use cloneDeepWith to skip cloning the blob
const clonedUsr = _.cloneDeepWith(userProfile, (value) => {
  if (value instanceof Blob) {
    return value; // Don't clone, return as-is
  }
});
console.warn("Cloned User Profile:");
console.log(clonedUsr);
console.warn("userProfile:");
console.log(userProfile);
// Check if the cloned object is a new object
console.log(clonedUsr === userProfile); // false (new object)
console.log(clonedUsr.profileImage === userProfile.profileImage); // true (blob is reused)
console.log(clonedUsr.preferences === userProfile.preferences); // false (deep cloned)
                        </pre>
                    </div>
                </div>
                <div class="col">
                    <div class="method-block" data-name="cloneMethods" id="cloneMethods">
                        <table class="table table-bordered table-hover table-condensed table-striped">
                            <tr>
                                <th> Method</th>
                                <th>Level Copied</th>
                                <th>Use When...</th>
                            </tr>
                            <tr>
                                <td>_.clone </td>
                                <td>Top-level only</td>
                                <td>You just need a copy and there are no nested objects</td>
                            </tr>
                            <tr>
                                <td>_.cloneDeep </td>
                                <td>Everything, deeply</td>
                                <td>You want full duplication, even nested stuff</td>
                            </tr>
                            <tr>
                                <td>_.cloneDeepWith </td>
                                <td>Deep + custom </td>
                                <td> rules You want control over how values are cloned</td>
                            </tr>
                        </table>
                    </div>
                </div>
            </div>
            <hr>
            <div class="row">
                <div class="col">
                    <div class="method-block" data-name="isArray" id="isArray">
                        <h4>_.isArray(value)</h4>
                        <p>Checks if the value is an array.</p>
                        <pre>
  const valuesCollection = [
            [1, 2, 3],
            "hello",
            { name: "Kesava" },
            123,
            null,
            undefined,
            true
    ];

  valuesCollection.forEach((val, index) => {
    console.log(`Value ${index + 1}:`, val, '| Is Array:', _.isArray(val));
  });

<span class="badge text-bg-success">Output :</span>
Value 1: Array(3) | Is Array: true
Value 2: hello | Is Array: false
Value 3: Object | Is Array: false
Value 4: 123 | Is Array: false
Value 5: null | Is Array: false
Value 6: undefined | Is Array: false
Value 7: true | Is Array: false
                        </pre>
                    </div>
                </div>
                <div class="col">
                    <div class="method-block" data-name="isboolean" id="isboolean">
                        <h4>_.isBoolean(value)</h4>
                        <p>Checks if the value is a boolean (true or false).</p>
                        <pre>
 const valuesCollectionTwo = [
    true,
    false,
    new Boolean(false), // object wrapper, not primitive
    0,
    1,
    "true",
    null,
    undefined
  ];

  valuesCollectionTwo.forEach((val, index) => {
    console.log(`Value ${index + 1}:`, val, "| isBoolean:", _.isBoolean(val));
  });

  <span class="badge text-bg-success">Output :</span>
Value 1: true | isBoolean: true
Value 2: false | isBoolean: true
Value 3: Boolean | isBoolean: true
Value 4: 0 | isBoolean: false
Value 5: 1 | isBoolean: false
Value 6: true | isBoolean: false
Value 7: null | isBoolean: false
Value 8: undefined | isBoolean: false
                        </pre>
                    </div>
                </div>
            </div>
            <hr>
            <div class="row">
                <div class="col">
                    <div class="method-block" data-name="isdate" id="isdate">
                        <h4>_.isDate(value)</h4>
                        <p>Checks if the value is a Date object.</p>
                        <pre>
const d1 = new Date();        // ✅ Date object
const d2 = Date.now();        // ❌ Just a number (timestamp)
const d3 = "2024-08-01";      // ❌ Just a string

console.log(_.isDate(d1)); // true
console.log( _.isDate(d2)); // false
console.log(_.isDate(d3)); // false
                        </pre>
                    </div>
                </div>
                <div class="col">
                    <div class="method-block" data-name="isempty" id="isempty">
                        <h4>_.isEmpty(value)</h4>
                        <p>Checks if the value is empty. An empty object, array, or string is considered empty.</p>
                        <pre>
const emptyObj = {};
const nonEmptyObj = { name: 'Kesava' };
const emptyArr = [];
const nonEmptyArr = [1, 2, 3];
const emptyStr = '';
const nonEmptyStr = 'Hello';
const nullValue = null;
const undefinedValue = undefined;
const numValue = 42;
const boolValue = true;
<span class="badge text-bg-success"> Output :</span>
console.log('emptyObj ->',_.isEmpty(emptyObj)); // true
console.log('nonEmptyObj ->',_.isEmpty(nonEmptyObj)); // false   
console.log('emptyArr ->',_.isEmpty(emptyArr)); // true
console.log('nonEmptyArr->',_.isEmpty(nonEmptyArr)); // false
console.log('emptyStr ->',_.isEmpty(emptyStr)); // true
console.log('nonEmptyStr ->',_.isEmpty(nonEmptyStr)); // false
console.log('nullValue ->',_.isEmpty(nullValue)); // true
console.log('undefinedValue',_.isEmpty(undefinedValue)); // true
console.log('numValue-> ',_.isEmpty(numValue)); // true (numbers are considered empty)
console.log('boolValue ->',_.isEmpty(boolValue)); // true (booleans are considered empty)
                        </pre>
                    </div>
                </div>
            </div>
            <hr>
            <div class="row">
                <div class="col">
                    <div class="method-block" data-name="isEqual" id="isEqual">
                        <h4>_.isEqual(value, other)</h4>
                        <p>Checks if two values are deeply equal — meaning it
                            compares not just the top-level values, but also nested structures inside them.</p>
                        <pre>
 const order1 = {
  id: 101,
  customer: { name: "Kesava", city: "Chennai" },
  items: [
    { product: "Laptop", qty: 1, price: 50000 },
    { product: "Mouse", qty: 1, price: 500 }
  ]
};

const order2 = {
  id: 101,
  customer: { name: "Kesava", city: "Chennai" },
  items: [
    { product: "Laptop", qty: 1, price: 50000 },
    { product: "Mouse", qty: 1, price: 500 }
  ]
};

// Normal equality check
console.log(order1 === order2); // false ❌ (different references)

// Deep equality check
console.log(_.isEqual(order1, order2)); // true ✅
<p> <span class="badge text-bg-warning">Note: </span>
    If all properties match, returns true
    If even one property’s value is different, returns false.</p>
console.log(_.isEqual(5, 5)); // true
console.log(_.isEqual(5, '5')); // false
console.log(_.isEqual([1, 2, 3], [1, 2, 3])); // true
console.log(_.isEqual({ a: 1 }, { a: 1 })); // true
console.log(_.isEqual({ a: 1 }, { a: 2 })); // false
console.log(_.isEqual(null, undefined)); // false
console.log(_.isEqual(null, null)); // true
console.log(_.isEqual(undefined, undefined)); // true
                        </pre>
                    </div>
                </div>
                <div class="col">
                    <div class="method-block" data-name="isInteger" id="isInteger">
                        <h4>_.isInteger(value)</h4>
                        <p>Checks if the value is an integer (whole number). (a number without any decimal part).</p>
                        <pre>
console.log(_.isInteger(4));         // true   → 4 is an integer
console.log(_.isInteger(4.0));       // true   → 4.0 is still an integer
console.log(_.isInteger(-4));        // true   → Negative integers are still integers   
console.log(_.isInteger(0));         // true   → 0 is also an integer

console.log(_.isInteger(4.5));       // false  → Has decimal part
console.log(_.isInteger(Math.PI));  // false   → Decimal value
console.log(_.isInteger('4'));       // false  → String, not a number
console.log(_.isInteger(NaN));       // false  → NaN is not an integer
console.log(_.isInteger(undefined)); // false  → Not a number at all
console.log(_.isInteger(null));      // false  → null is not a number
console.log(_.isInteger(true));      // false  → Boolean true is not an integer
console.log(_.isInteger(false));     // false  → Boolean false is not an integer
                
function canBookSeats(seats) {
  if (_.isInteger(seats) && seats > 0) {
    return "Booking confirmed!";
  } else {
    return "Please enter a valid whole number of seats.";
  }
}

console.log(canBookSeats(3));     // "Booking confirmed!"
console.log(canBookSeats(3.0));   // "Booking confirmed!"
console.log(canBookSeats(0.5));   // "Please enter a valid whole number of seats."
console.log(canBookSeats(3.5));   // "Please enter a valid whole number of seats."
console.log(canBookSeats('3'));   // "Please enter a valid whole number of seats."
console.log(canBookSeats(-2));    // "Please enter a valid whole number of seats."
console.log(canBookSeats(0));     // "Please enter a valid whole number of seats
                        </pre>
                    </div>
                </div>
                <hr>
                <div class="row">
                    <div class="col">
                        <div class="method-block" data-name="isnumber" id="isnumber">
                            <h4>_.isNumber(value)</h4>
                            <p>Checks if the value is a number (including integers, floats, and NaN).</p>
                            <pre>
console.log(_.isNumber(42));          // true   → 42 is a number
console.log(_.isNumber(3.14));        // true   → 3.14 is a number
console.log(_.isNumber(NaN));         // true   → NaN is considered a number
console.log(_.isNumber(Infinity));    // true   → Infinity is a number
console.log(_.isNumber(-Infinity));   // true   → -Infinity is a number
console.log(_.isNumber(0));           // true   → 0 is a number
console.log(_.isNumber(4.0));         // true   → 4.0 is still a number
console.log(_.isNumber(4.5));         // true   → 4.5 is a number
console.log(_.isNumber(Number('42'))); // true   → Number('42') is a number
console.log(_.isNumber(Number('3.14'))); // true   → Number('3.14') is a number
console.log(_.isNumber(Number('NaN'))); // true   → Number('NaN') is a number (NaN)
console.log(_.isNumber(Number('')));  // true   → Number('') is 0, which is a number
console.log(_.isNumber(Number('abc'))); // true → Number('abc') is NaN, which is a number

console.log(_.isNumber('42'));        // false  → '42' is a string      
console.log(_.isNumber(undefined));   // false  → undefined is not a number
console.log(_.isNumber(null));        // false  → null is not a number
console.log(_.isNumber(true));        // false  → true is a boolean, not a number
console.log(_.isNumber(false));       // false  → false is a boolean, not a number
console.log(_.isNumber({}));          // false  → {} is an object, not a number
console.log(_.isNumber([]));          // false  → [] is an array, not a number
console.log(_.isNumber('3.14'));      // false  → '3.14' is a string, not a number
console.log(_.isNumber('NaN'));       // false  → 'NaN' is a string, not a number
                        </pre>
                        </div>
                    </div>
                    <div class="col">
                        <div class="method-block" data-name="ismatch" id="ismatch">
                            <h4>_.isMatch(object, source)</h4>
                            <p>Checks if an object contains all key-value pairs from a source object.</p>
                            <p><span class="badge text-bg-warning">Note : </span>It’s like asking: "Does this object
                                have at least these key-value pairs?" <br>
                                If the source object has properties that match the object, it returns true. <br>
                                Partial deep comparison is allowed.</p>
                            <pre>
const userr = { name: 'John', age: 30, role: 'Admin' };
console.log(_.isMatch(userr, { age: 30 }));        // true ✅
console.log(_.isMatch(userr, { role: 'Admin' }));  // true ✅
console.log(_.isMatch(userr, { age: 25 }));        // false ❌
console.log(_.isMatch(userr, { name: 'John', age: 30 })); // true ✅
console.log(_.isMatch(userr, { name: 'John', age: 25 })); // false ❌
console.log(_.isMatch(userr, { name: 'John', role: 'User' })); // false ❌

const order = {
  id: 101,
  customer: { name: 'Alice', city: 'Chennai' },
  total: 500
};
console.log(_.isMatch(order, { customer: { city: 'Chennai' } })); // true ✅
console.log(_.isMatch(order, { customer: { city: 'Delhi' } }));   // false ❌

const home = {
  owner: 'Kesava',
  rooms: { bedroom: 2, kitchen: 1 },
  location: 'India'
};

// Check if the home has at least 2 bedrooms
console.log(_.isMatch(home, { rooms: { bedroom: 2 } })); // true ✅

// Check if the home has 3 bedrooms
console.log(_.isMatch(home, { rooms: { bedroom: 3 } })); // false ❌
                        </pre>
                        </div>
                    </div>
                </div>
                <hr>
                <div class="row">
                    <div class="col">
                        <div class="method-block" data-name="" id="">
                            <h4>_.isNaN(value)</h4>
                            <p>Checks if the value is NaN (Not a Number).</p><br>
                            <p>NaN literally means “Not a Number” <br>
                                But ironically, in JavaScript, NaN itself is of type number.</p>
                            <pre>
console.log('typeof NaN -->',typeof NaN); // "number"

const setOfValues = [NaN, 42, 'hello', undefined, null, true, false, {}, []];
setOfValues.forEach((val, index) => {
    console.log(`Value ${index + 1}:`, val, '| Is NaN:', _.isNaN(val));
})
                        </pre>
                        </div>
                    </div>
                    <div class="col">
                        <div class="method-block" data-name="isnil" id="isnil">
                            <h4>_.isNil(value)</h4>
                            <p>Checks if the value is null or undefined.</p>
                            <p>It’s basically a shortcut for: <br>
                                value === null || value === undefined // true</p>
                            <pre>
 const userData = {
    name: 'Kesava',   
    age: 30,
}

if (<b>!_.isNil(userData)</b>) {
  console.log("User exists:", user);
} else {
  console.log("User is missing!");
}

const valuesToCheck = [
  null,
  undefined,
  0,
  '',
  false,
  NaN,
  'Hello',
  [],
  {},
  [1, 2, 3],
  { a: 1 }
]
valuesToCheck.forEach((data,slNo)=>{
  console.log(`Sl.No :${slNo +1 } - Value: ${data} - Is Nil: ${_.isNil(data)}`);
})
                        </pre>
                        </div>
                    </div>
                </div>
                <hr>
                <div class="row">
                    <div class="col">
                        <div class="method-block" data-name="isnull" id="isnull">
                            <h4>_.isNull(value)</h4>
                            <p>Checks if the value is exactly null. <br>
                                It will not return true for undefined.</p>
                            <pre>
const valuesToCheckNull = [
    null,
    undefined,
    0,
    '',
    false,
    NaN,
    'Hello',
    [],
    {},
    [1, 2, 3],
    { a: 1 }
]
valuesToCheckNull.forEach((data, slNo) => {
  console.log(`Sl.No: ${slNo + 1} - Value: ${data} - Is Null: ${_.isNull(data)}`);
})
                        </pre>
                        </div>
                    </div>
                    <div class="col">
                        <div class="method-block" data-name="isobject" id="isobject">
                            <h4>_.isObject(value)</h4>
                            <p>Checks if the given value is an object. <br>
                                (It includes arrays, functions, objects, regex, dates, wrapper objects, etc., because in
                                JavaScript they’re all technically “objects”.)</p>
                            <pre>
const mixedValues = [
    { name: 'Kesava' }, // Object
    [1, 2, 3],         // Array
    'Hello',           // String
    42,                // Number
    null,              // Null
    undefined,         // Undefined
    true,              // Boolean
    new Date()        // Date object
];

<span class="badge text-bg-warning"><b>Modern method of foreach</b></span>
for(const [i,val] of mixedValues.entries()){
  console.log(`Sl.no: ${i + 1}:`, val, '| Is Object:', _.isObject(val));
}
                        </pre>
                        </div>
                    </div>
                </div>
                <hr>
                <div class="row">
                    <div class="col">
                        <div class="method-block" data-name="isstring" id="isstring">
                            <h4>_.isString(value)</h4>
                            <p>Checks if the given value is a string primitive ('hello') or a String object (new
                                String('hello')).</p>
                            <pre>
    function validateName(name) {                            
        if (_.isString(name) && !_.isEmpty(name)) {
            console.log("Valid name:", name);
            } else {
            console.log("Invalid name!");
        }
    }

validateName("Raj"); // Valid name: Raj
validateName(123); // Invalid name!
validateName(""); // Invalid name!
validateName(null); // Invalid name!
validateName(undefined); // Invalid name!
validateName(""); // Invalid name!
validateName("Anbu"); // Valid name: Anbu
validateName(456); // Invalid name!

    const stringValues = [
        'Hello',
        '123',
        '',
        null,
        undefined,
        true,
        false,
        {},
        [],
        new Date()
    ];

stringValues.forEach((val, index) => {
  console.log(`Sl.no ${index + 1}:`, val, '| Is String:', _.isString(val));
});
                            </pre>
                        </div>
                    </div>
                    <div class="col">
                        <div class="method-block" data-name="toarray" id="toarray">
                            <h4>_.toArray(value)</h4>
                            <p>Converts a value to an array. If the value is already an array, it returns a shallow copy
                                of that array.</p>
                            <p>_.toArray = normalize anything into an array → safe for iteration.</p>
                            <pre>
const mixedValues = [
    { name: 'Kesava' }, // Object   
    [1, 2, 3],         // Array
    'Hello',           // String
    42,                // Number
    null,              // Null
    undefined,         // Undefined
    true,              // Boolean   
    new Date()        // Date object
];

mixedValues.forEach((val, index) => {
    const arrayValue = _.toArray(val);
    console.log(`Sl.no ${index + 1}:`, val, '| Converted to Array:', arrayValue);
});

<p><span class="badge text-bg-warning">Note: </span> <b>filter objcts using toArray</b></p>
const objectToArray = { tamil: 70, english: 72, maths: 35, science: 60, social: 50 };
const arrayFromObject = _.toArray(objectToArray);
console.log('Object to Array:', arrayFromObject);
const highMarks = arrayFromObject.filter((mark)=>mark >50);
console.log('Marks greater than 50:', highMarks);
                            </pre>
                        </div>
                    </div>
                </div>
                <hr>
                <div class="row">
                    <div class="col">
                        <div class="method-block" data-name="tointeger" id="tointeger">
                            <h4>_.toInteger(value)</h4>
                            <p>Converts a value to an integer. If the value is already an integer, it returns that
                                value.
                                If the value is a float, it rounds it down to the nearest integer.</p>
                            <pre>
const valuesToCheckInteger = [
    42,                // Integer
    3.14,              // Float     
    -7,                // Negative Integer
    0,                 // Zero
    '100',             // String
    null,              // Null
    undefined,         // Undefined     
    true,              // Boolean
    false,             // Boolean
    {},                // Object
    [],                // Array
    new Date() ,       // Date object
    20.67
];
valuesToCheckInteger.forEach((val, index) => {
    console.log(`Sl.no ${index + 1}:`, val, '| Is Integer:', _.toInteger(val));
});
                            </pre>
                        </div>
                    </div>
                    <div class="col">
                        <div class="method-block" data-name="tonumber" id="tonumber">
                            <h4>_.toNumber(value)</h4>
                            <p>Converts a value to a number. If the value is already a number, it returns that value.
                                If the value is a string that can be converted to a number, it converts it.</p>
                            <pre>
const valuesToCheckNumber = [
        42,                // Integer   
        3.14,              // Float
        -7,                // Negative Integer
        0,                 // Zero
        '100',             // String
        null,              // Null
        undefined,         // Undefined
        true,              // Boolean
        false,             // Boolean
        {},                // Object
        [],                // Array
        new Date(),       // Date object
        '20.67',           // String with decimal
        'abc',             // Non-numeric string
        '123abc'           // Mixed string
];

valuesToCheckNumber.forEach((val, index) => {
    console.log(`Sl.no ${index + 1}:`, val, '| Converted to Number:', _.toNumber(val));
});
                            </pre>
                        </div>
                    </div>
                </div>
                <hr>
                <div class="row">
                    <div class="col"></div>
                    <div class="col"></div>
                </div>
                <script>
                    // scroll to top functionality
                    const scrollBtn = document.getElementById('scrollTopBtn');
                    window.onscroll = function () {
                        if (document.body.scrollTop > 100 || document.documentElement.scrollTop > 100) {
                            scrollBtn.style.display = "flex";
                        } else {
                            scrollBtn.style.display = "none";
                        }
                    };
                    scrollBtn.onclick = function () {
                        window.scrollTo({
                            top: 0,
                            behavior: 'smooth'
                        });
                    };
                    const searchBox = document.getElementById('searchBox');
                    searchBox.addEventListener('input', function () {
                        const keyword = this.value.toLowerCase();
                        const methods = document.querySelectorAll('.method-block');
                        const hrs = document.querySelectorAll('hr');
                        const noResults = document.getElementById('noResults');
                        let anyVisible = false;
                        // Show/hide methods based on match
                        methods.forEach(method => {
                            const methodName = method.dataset.name.toLowerCase();
                            const isMatch = methodName.includes(keyword);
                            method.style.display = isMatch ? 'block' : 'none';
                            if (isMatch) {
                                // Hide all hr tags
                                hrs.forEach(hr => hr.style.display = 'none');
                                anyVisible = true;
                            }
                        });
                        // Show or hide "No results found" message
                        noResults.style.display = anyVisible ? 'none' : 'block';
                    });

                </script>
</body>

</html>